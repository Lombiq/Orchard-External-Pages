@model OrchardHUN.ExternalPages.Models.BitbucketRepositoryDataRecord
@using OrchardHUN.ExternalPages.Models

@{
    var isExisting = Model.Id != 0;
}
<fieldset class="orchardhun-external-pages-bitbucket-repository-settings">
    <legend>
        @if (isExisting)
        {
            @Model.AccountName<text>/</text>@Model.Slug
        }
        else
        {
            @T("New repository")
        }
    </legend>
    <div>
        @Html.HiddenFor(m => m.Id)
        @if (isExisting)
        {
            @Html.ActionLink(T("Delete repository").Text, "DeleteRepository", "BitbucketAdmin", new { Area = "OrchardHUN.ExternalPages", Id = Model.Id, ReturnUrl = Context.Request.RawUrl }, new { itemprop = "RemoveUrl UnsafeUrl", @class = "button" })
            <span class="hint">@T("Deleting the repository will also remove content items.")</span>
            @Html.ActionLink(T("Repopulate").Text, "RepopulateRepository", "BitbucketAdmin", new { Area = "OrchardHUN.ExternalPages", Id = Model.Id, ReturnUrl = Context.Request.RawUrl }, new { itemprop = "UnsafeUrl", @class = "button" })
            if (!Model.WasChecked())
            {
                <span class="hint">@T("This repository wasn't populated yet.")</span>
            }
            <span class="hint">@T("Bypassing changeset processing you can force a repopulation of the local storage from the repository's current state. Make sure to set up url mappings properly first. Before the initial population the repository's content won't be pulled in so clicking this is necessary before the content will be auto-updated.")</span>
            if (Model.WasProcessed())
            {
                @T("Open root urls:")
                <ul>
                    @foreach (var mapping in Model.UrlMappings())
                    {
                        var remoteUrl = "/" + mapping.RepoPath;
                        var localUrl = Url.Content("~/" + mapping.LocalPath);
                        <li>
                            @Html.Link(remoteUrl + ": " + localUrl, localUrl)
                        </li>
                    }
                </ul>
            }
        }
        <ol>
            <li>
                @Html.LabelFor(m => m.AccountName, T("Account name"))
                @if (isExisting)
                {
                    @Html.TextBoxFor(m => m.AccountName, new { @class = "text singleline", @readonly = "readonly" })
                }
                else
                {
                    @Html.TextBoxFor(m => m.AccountName, new { @class = "text singleline" })
                }
                
                @Html.ValidationMessageFor(m => m.AccountName)
            </li>
            <li>
                @Html.LabelFor(m => m.Slug, T("Slug"))
                @if (isExisting)
                {
                    @Html.TextBoxFor(m => m.Slug, new { @class = "text singleline", @readonly = "readonly" })
                }
                else
                {
                    @Html.TextBoxFor(m => m.Slug, new { @class = "text singleline" })
                }
                @Html.ValidationMessageFor(m => m.Slug)
            </li>
            <li>
                @Html.LabelFor(m => m.Username, T("Username"))
                @Html.TextBoxFor(m => m.Username, new { @class = "text singleline" })
                @Html.ValidationMessageFor(m => m.Username)
            </li>
            <li>
                @Html.LabelFor(m => m.Password, T("Password"))
                @Html.PasswordFor(m => m.Password, new { @class = "text singleline" })
                @Html.ValidationMessageFor(m => m.Password)
            </li>
            <li>
                @Html.EditorFor(m => m.MirrorFiles)
                <label for="@Html.FieldIdFor(m => m.MirrorFiles)" class="forcheckbox">@T("Mirror files")</label>
                @Html.ValidationMessageFor(m => m.MirrorFiles)
                <span class="hint">@T("Check to download non-markdown files (like images, documents...) to the Orchard file system so you can access them from under a local url. Markdown files will be downloaded and converted to content items regardless of this option.")</span>
            </li>
            <li>
                @Html.LabelFor(m => m.MaximalFileSizeKB, T("Maximal file size (in KB)"))
                @Html.TextBoxFor(m => m.MaximalFileSizeKB, new { @class = "text-small" })
                @Html.ValidationMessageFor(m => m.MaximalFileSizeKB)
                <span class="hint">@T("Define a maximal file size for non-markdown files. If a file to be mirrored locally is too large the background task downloading it can time out.")</span>
            </li>
            <li>
                @Html.LabelFor(m => m.UrlMappingsDefinition, T("Url mappings"))
                @Html.TextAreaFor(m => m.UrlMappingsDefinition, new { @class = "text singleline" })
                @Html.ValidationMessageFor(m => m.UrlMappingsDefinition)
                <span class="hint">@T("Write mappings between the path of a document folder in the repo and the root url of the corresponding document items here, separated with a colon, one per line. Sample: Folder/In/Repo: LocalRoot|Another/Folder/In/Repo: OtherLocalRoot.")</span>
            </li>
        </ol>
    </div>
</fieldset>
